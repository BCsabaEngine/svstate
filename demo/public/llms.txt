# svstate Demo

Interactive demo app showcasing svstate features - a Svelte 5 library for deep reactive state with validation, snapshot/undo, and side effects.

## Demo Pages

### BasicValidation

Demonstrates form validation with string, number, and email validators using the fluent API.

**APIs:** createSvState(), stringValidator(), numberValidator(), getError()
**Stores:** errors, hasErrors, isDirty

```typescript
const sourceData = {
  username: '',
  email: '',
  age: 0,
  bio: '',
  website: ''
};

const {
  data,
  state: { errors, hasErrors, isDirty }
} = createSvState(sourceData, {
  validator: (source) => ({
    username: stringValidator(source.username).prepare('trim').required().minLength(3).maxLength(20).noSpace().getError(),
    email: stringValidator(source.email).prepare('trim').required().email().getError(),
    age: numberValidator(source.age).required().min(18).max(120).integer().getError(),
    bio: stringValidator(source.bio).maxLength(200).getError(),
    website: stringValidator(source.website).prepare('trim').website('required').getError()
  })
});
```

```svelte
<input
  type="text"
  class="{$errors?.username ? 'error-styles' : 'normal-styles'}"
  bind:value={data.username}
/>
<ErrorText error={$errors?.username ?? ''} />
```

---

### NestedObjects

Illustrates validating deeply nested object structures with multi-level property paths.

**APIs:** createSvState(), stringValidator()
**Stores:** errors, hasErrors, isDirty

```typescript
const sourceData = {
  name: '',
  address: { street: '', city: '', zip: '' },
  company: {
    name: '',
    department: '',
    contact: { phone: '', email: '' }
  }
};

const {
  data,
  state: { errors, hasErrors, isDirty }
} = createSvState(sourceData, {
  validator: (source) => ({
    name: stringValidator(source.name).prepare('trim').required().minLength(2).maxLength(50).getError(),
    address: {
      street: stringValidator(source.address.street).prepare('trim').required().minLength(5).getError(),
      city: stringValidator(source.address.city).prepare('trim').required().minLength(2).getError(),
      zip: stringValidator(source.address.zip).prepare('trim').required().minLength(5).maxLength(10).getError()
    },
    company: {
      name: stringValidator(source.company.name).prepare('trim').required().minLength(2).getError(),
      department: stringValidator(source.company.department).prepare('trim').maxLength(50).getError(),
      contact: {
        phone: stringValidator(source.company.contact.phone).prepare('trim').required().minLength(10).getError(),
        email: stringValidator(source.company.contact.email).prepare('trim').required().email().getError()
      }
    }
  })
});
```

```svelte
<!-- 2-level nested binding -->
<input bind:value={data.address.street} />
<ErrorText error={$errors?.address?.street ?? ''} />

<!-- 3-level nested binding -->
<input bind:value={data.company.contact.phone} />
<ErrorText error={$errors?.company?.contact?.phone ?? ''} />
```

---

### ArrayProperty

Shows how to validate dynamic arrays with per-item validation using indexed error keys.

**APIs:** createSvState(), arrayValidator(), stringValidator()
**Stores:** errors, hasErrors, isDirty

```typescript
type ItemErrors = Record<string, { name?: string; email?: string }>;

const sourceData = {
  listName: '',
  items: [] as { name: string; email: string }[]
};

const {
  data,
  state: { errors, hasErrors, isDirty }
} = createSvState(sourceData, {
  validator: (source) => ({
    listName: stringValidator(source.listName).prepare('trim').required().minLength(2).getError(),
    items: arrayValidator(source.items).required().minLength(1).getError(),
    ...Object.fromEntries(
      source.items.map((item, index) => [
        `item_${index}`,
        {
          name: stringValidator(item.name).prepare('trim').required().minLength(2).getError(),
          email: stringValidator(item.email).prepare('trim').required().email().getError()
        }
      ])
    )
  })
});

const addItem = () => {
  data.items = [...data.items, { name: '', email: '' }];
};

const removeItem = (index: number) => {
  data.items = data.items.filter((_, i) => i !== index);
};
```

```svelte
{#each data.items as item, index}
  <input bind:value={item.name} />
  <ErrorText error={($errors as ItemErrors)?.[`item_${index}`]?.name ?? ''} />

  <input bind:value={item.email} />
  <ErrorText error={($errors as ItemErrors)?.[`item_${index}`]?.email ?? ''} />
{/each}
```

---

### CalculatedFields

Uses the effect callback to automatically compute derived values like subtotals, taxes, and totals.

**APIs:** createSvState(), effect callback
**Stores:** errors, hasErrors, isDirty

```typescript
const TAX_RATE = 0.08;

const sourceData = {
  productName: '',
  item: { unitPrice: 0, quantity: 1 },
  subtotal: 0,
  tax: 0,
  total: 0
};

const {
  data,
  state: { errors, hasErrors, isDirty }
} = createSvState(sourceData, {
  validator: (source) => ({
    productName: stringValidator(source.productName).prepare('trim').required().minLength(2).getError(),
    item: {
      unitPrice: numberValidator(source.item.unitPrice).required().positive().getError(),
      quantity: numberValidator(source.item.quantity).required().integer().min(1).max(100).getError()
    }
  }),
  effect: ({ property }) => {
    if (property === 'item.unitPrice' || property === 'item.quantity') {
      data.subtotal = data.item.unitPrice * data.item.quantity;
      data.tax = data.subtotal * TAX_RATE;
      data.total = data.subtotal + data.tax;
    }
  }
});
```

---

### SnapshotDemo

Shows snapshot creation for undo functionality with rollback() support.

**APIs:** createSvState(), snapshot(), rollback(), reset()
**Stores:** errors, hasErrors, isDirty, snapshots

```typescript
const sourceData = {
  firstName: 'Alice',
  lastName: 'Smith',
  email: 'alice.smith@example.com',
  phone: '',
  bio: ''
};

const {
  data,
  reset,
  rollback,
  state: { errors, hasErrors, isDirty, snapshots }
} = createSvState(sourceData, {
  validator: (source) => ({
    firstName: stringValidator(source.firstName).prepare('trim').required().minLength(2).maxLength(30).getError(),
    lastName: stringValidator(source.lastName).prepare('trim').required().minLength(2).maxLength(30).getError(),
    email: stringValidator(source.email).prepare('trim').required().email().getError(),
    phone: stringValidator(source.phone).prepare('trim').required().minLength(10).getError(),
    bio: stringValidator(source.bio).maxLength(200).getError()
  }),
  effect: ({ snapshot, property }) => {
    snapshot(`Changed ${property}`);
  }
});
```

```svelte
<!-- Undo last change (disabled if only initial snapshot) -->
<button onclick={() => rollback()} disabled={$snapshots.length <= 1}>
  Undo Last Change
</button>

<!-- Rollback multiple steps -->
<button onclick={() => rollback(3)}>Undo 3 Changes</button>

<!-- Reset to initial state -->
<button onclick={reset}>Reset All</button>

<!-- Display snapshot history -->
{#each $snapshots as snap, index}
  <li>{index + 1}. {snap.title}</li>
{/each}
```

---

### ResetDemo

Demonstrates the reset() function to restore state back to its initial values.

**APIs:** createSvState(), reset()
**Stores:** errors, hasErrors, isDirty

```typescript
const sourceData = {
  firstName: 'Alice',
  lastName: 'Smith',
  email: 'alice.smith@example.com',
  phone: '',
  bio: ''
};

const {
  data,
  reset,
  state: { errors, hasErrors, isDirty }
} = createSvState(sourceData, {
  validator: (source) => ({
    firstName: stringValidator(source.firstName).prepare('trim').required().minLength(2).maxLength(30).getError(),
    lastName: stringValidator(source.lastName).prepare('trim').required().minLength(2).maxLength(30).getError(),
    email: stringValidator(source.email).prepare('trim').required().email().getError(),
    phone: stringValidator(source.phone).prepare('trim').required().minLength(10).getError(),
    bio: stringValidator(source.bio).maxLength(200).getError()
  })
});
```

```svelte
<!-- Reset button only appears when form is dirty -->
{#if $isDirty}
  <button onclick={reset}>Reset to Initial Values</button>
{/if}
```

---

### ActionDemo

Demonstrates async action execution with loading states and error handling.

**APIs:** createSvState(), execute(), action, actionCompleted
**Stores:** errors, hasErrors, isDirty, actionInProgress, actionError

```typescript
const sourceData = {
  title: '',
  description: ''
};

const {
  data,
  execute,
  state: { errors, hasErrors, isDirty, actionInProgress, actionError }
} = createSvState(sourceData, {
  validator: (source) => ({
    title: stringValidator(source.title).prepare('trim').required().minLength(3).maxLength(50).getError(),
    description: stringValidator(source.description).prepare('trim').required().minLength(10).maxLength(200).getError()
  }),
  action: async () => {
    await new Promise((resolve) => setTimeout(resolve, 500));
    // Perform API call here
    if (shouldFail) throw new Error('Server error');
  },
  actionCompleted: (error) => {
    if (error) console.log('Action failed:', error);
    else console.log('Action succeeded');
  }
});
```

```svelte
<!-- Submit button with loading state -->
<button onclick={() => execute()} disabled={$hasErrors || $actionInProgress}>
  {$actionInProgress ? 'Submitting...' : 'Submit'}
</button>

<!-- Display action error -->
{#if $actionError}
  <div class="error">{$actionError.message}</div>
{/if}

<!-- Loading indicator -->
{#if $actionInProgress}
  <div class="loading">Submitting...</div>
{/if}
```

---

### OptionsDemo

Interactive playground for configuring createSvState options like debouncing and error persistence.

**APIs:** createSvState() with options parameter
**Options:** resetDirtyOnAction, debounceValidation, persistActionError

```typescript
const { data, execute, state } = createSvState(
  sourceData,
  {
    validator: (source) => ({ /* ... */ }),
    effect: ({ property }) => { /* ... */ },
    action: async () => { /* ... */ }
  },
  {
    // Reset isDirty to false after successful action
    resetDirtyOnAction: true,    // default: true

    // Debounce validation by N milliseconds
    debounceValidation: 0,       // default: 0 (uses queueMicrotask)

    // Keep action errors until next action (not cleared on data change)
    persistActionError: false    // default: false
  }
);
```

```typescript
// resetDirtyOnAction behavior
// With true (default): isDirty becomes false after successful execute()
// With false: isDirty remains true after execute()

// debounceValidation behavior
// With 0 (default): Validation runs via queueMicrotask after each change
// With 500: Validation runs 500ms after the last change (useful for rapid typing)

// persistActionError behavior
// With false (default): actionError clears when data changes
// With true: actionError remains until next execute() call
```

---

### AsyncValidation

Demonstrates async validation with simulated API calls for username, email, and slug uniqueness checks.

**APIs:** createSvState(), stringValidator(), asyncValidator
**Stores:** errors, hasErrors, isDirty, asyncErrors, hasAsyncErrors, asyncValidating, hasCombinedErrors

```typescript
const { data, state: { errors, asyncErrors, asyncValidating, hasCombinedErrors } } =
  createSvState(sourceData, {
    validator: (source) => ({
      username: stringValidator(source.username).required().minLength(3).noSpace().getError(),
      email: stringValidator(source.email).required().email().getError(),
      slug: stringValidator(source.slug).required().minLength(2).slug().getError()
    }),
    asyncValidator: {
      username: async (value, source, signal) => {
        const res = await fetch(`/api/check-username?u=${value}`, { signal });
        return (await res.json()).available ? '' : 'Username already taken';
      },
      email: async (value, source, signal) => {
        const res = await fetch(`/api/check-email?e=${value}`, { signal });
        return (await res.json()).available ? '' : 'Email already registered';
      }
    }
  },
  { maxConcurrentAsyncValidations: 2 }
);
```

```svelte
<!-- Show loading spinner when validating -->
{#if $asyncValidating.includes('username')}
  <span class="animate-spin">...</span>
{/if}

<!-- Show async error -->
{#if $asyncErrors.username}
  <span class="text-red-500">{$asyncErrors.username}</span>
{/if}

<!-- Disable submit when any errors -->
<button disabled={$hasCombinedErrors}>Submit</button>
```

---

### ZodValidation

Demonstrates using Zod schemas for validation with svstate, including dynamic form rendering via z.pick() shape keys.

**APIs:** createSvState(), Zod integration
**Stores:** errors, hasErrors, isDirty, isDirtyByField

```typescript
import { z } from 'zod';

const userSchema = z.object({
  username: z.string().min(3).max(20).regex(/^\S+$/, 'Must not contain spaces'),
  email: z.string().min(1, 'Required').email(),
  age: z.number().int().min(18).max(120),
  website: z.string().url().optional().or(z.literal('')),
  bio: z.string().max(200).optional()
});

function zodToSvstateErrors(schema, source, fields) {
  const result = schema.safeParse(source);
  if (result.success)
    return Object.fromEntries(fields.map(f => [f, '']));

  const errorMap = {};
  for (const issue of result.error.issues) {
    const key = String(issue.path[0]);
    if (!errorMap[key]) errorMap[key] = issue.message;
  }
  return Object.fromEntries(fields.map(f => [f, errorMap[f] ?? '']));
}

const { data, state: { errors, hasErrors } } = createSvState(sourceData, {
  validator: (source) => zodToSvstateErrors(userSchema, source, allFields)
});
```

---

### CalculatedClass

Demonstrates using objects with methods as state. Methods are preserved through snapshots, rollback, and reset. The effect callback can call methods directly on the state object.

**APIs:** createSvState(), stringValidator(), numberValidator(), state methods
**Stores:** errors, hasErrors, isDirty

```typescript
type SourceData = {
  productName: string;
  item: { unitPrice: number; quantity: number };
  subtotal: number;
  tax: number;
  total: number;
  formatTotal: () => string;
  formatCurrency: (value: number) => string;
  calculateTotals: (taxRate?: number) => void;
};

const createSourceData = (): SourceData => ({
  productName: '',
  item: { unitPrice: 0, quantity: 1 },
  subtotal: 0,
  tax: 0,
  total: 0,
  formatTotal() {
    return `$${this.total.toFixed(2)}`;
  },
  formatCurrency(value: number) {
    return `$${value.toFixed(2)}`;
  },
  calculateTotals(taxRate: number = 0.08) {
    this.subtotal = this.item.unitPrice * this.item.quantity;
    this.tax = this.subtotal * taxRate;
    this.total = this.subtotal + this.tax;
  }
});

const { data, state: { errors, hasErrors, isDirty } } = createSvState(createSourceData(), {
  validator: (source) => ({
    productName: stringValidator(source.productName).prepare('trim').required().minLength(2).getError(),
    item: {
      unitPrice: numberValidator(source.item.unitPrice).required().positive().getError(),
      quantity: numberValidator(source.item.quantity).required().integer().min(1).max(100).getError()
    }
  }),
  effect: ({ property }) => {
    if (property === 'item.unitPrice' || property === 'item.quantity') {
      data.calculateTotals();  // Call method on state object!
    }
  }
});
```

```svelte
<!-- Use class methods for formatting -->
<span>{data.formatCurrency(data.subtotal)}</span>
<span>{data.formatTotal()}</span>
```

---

### PluginDevtools

Shows devtoolsPlugin console logging and a custom log-mirror plugin that captures all lifecycle events in-page.

**APIs:** createSvState(), devtoolsPlugin(), custom SvStatePlugin
**Stores:** errors, hasErrors, isDirty, snapshots, actionInProgress

```typescript
import { createSvState, devtoolsPlugin, type SvStatePlugin, type ChangeEvent } from 'svstate';

// Custom plugin that mirrors events to an in-page log
const logMirrorPlugin: SvStatePlugin<State> = {
  name: 'log-mirror',
  onChange(event: ChangeEvent<State>) {
    addLog('change', `${event.property}: "${event.oldValue}" â†’ "${event.currentValue}"`);
  },
  onValidation(errors) {
    addLog('validation', errors ? 'Has errors' : 'Valid');
  },
  onSnapshot(snapshot) {
    addLog('snapshot', snapshot.title);
  },
  onAction(event) {
    if (event.phase === 'before') addLog('action', 'Action started');
    else addLog('action', event.error ? `Action failed` : 'Action completed');
  },
  onRollback(snapshot) {
    addLog('rollback', `Rolled back to: ${snapshot.title}`);
  },
  onReset() {
    addLog('reset', 'State reset to initial');
  }
};

const { data, execute, reset, rollback, state } = createSvState(
  { name: '', email: '', message: '' },
  { validator, effect, action },
  {
    plugins: [
      devtoolsPlugin({
        name: 'my-form',     // Label in console
        enabled: true,        // Auto-disabled in production
        collapsed: true,      // Console groups collapsed
        logValidation: true   // Also log validation events
      }),
      logMirrorPlugin
    ]
  }
);
```

---

### PluginPersistSync

Settings form with persistPlugin (localStorage) and syncPlugin (cross-tab sync via BroadcastChannel).

**APIs:** createSvState(), persistPlugin(), syncPlugin()
**Stores:** errors, hasErrors, isDirty

```typescript
import { createSvState, persistPlugin, syncPlugin } from 'svstate';

const persist = persistPlugin({
  key: 'svstate-demo-settings',
  throttle: 300,
  exclude: ['notifications']  // Don't persist this field
});

const sync = syncPlugin({
  key: 'svstate-demo-sync',
  throttle: 200
});

const { data, reset, state } = createSvState(
  { username: '', theme: 'light', fontSize: 14, notifications: true },
  { validator: (source) => ({ /* ... */ }) },
  { plugins: [persist, sync] }
);

// persistPlugin API
persist.isRestored();          // true if data was loaded from storage
persist.clearPersistedState(); // Remove stored data

// syncPlugin: automatic cross-tab sync via BroadcastChannel
// Changes in one tab appear in all other tabs with same key
```

---

### PluginUndoRedo

Combines the built-in snapshot/rollback system with the undoRedoPlugin for full undo/redo support.

**APIs:** createSvState(), undoRedoPlugin(), rollback()
**Stores:** errors, hasErrors, isDirty, snapshots

```typescript
import { createSvState, undoRedoPlugin } from 'svstate';

const undoRedo = undoRedoPlugin();

const { data, reset, rollback, state } = createSvState(
  { title: 'My Document', content: '', priority: 'medium' },
  {
    validator: (source) => ({ /* ... */ }),
    effect: ({ snapshot, property }) => {
      snapshot(`Changed ${property}`);
    }
  },
  { maxSnapshots: 10, plugins: [undoRedo] }
);

// Undo (built-in rollback)
rollback();

// Redo (from undoRedoPlugin)
undoRedo.redo();

// Check if redo is available
undoRedo.canRedo(); // boolean

// Subscribe to redo stack
undoRedo.redoStack; // Readable<Snapshot[]>
```

---

### PluginAutosaveAnalytics

Auto-save with idle timer (autosavePlugin) and batched event analytics (analyticsPlugin).

**APIs:** createSvState(), autosavePlugin(), analyticsPlugin()
**Stores:** errors, hasErrors, isDirty, actionInProgress

```typescript
import { createSvState, autosavePlugin, analyticsPlugin } from 'svstate';

const autosave = autosavePlugin({
  save: async (data) => {
    await fetch('/api/save', {
      method: 'POST',
      body: JSON.stringify(data)
    });
  },
  idle: 2000,           // Save 2s after last change
  onlyWhenDirty: true   // Skip save if nothing changed
});

const analytics = analyticsPlugin({
  onFlush: (events) => {
    sendToAnalytics(events);  // Your analytics endpoint
  },
  batchSize: 10,        // Flush after 10 events
  flushInterval: 10000, // Or every 10 seconds
  include: ['change', 'action', 'snapshot']  // Filter event types
});

const { data, execute, state } = createSvState(
  initialData, actuators,
  { plugins: [autosave, analytics] }
);

// autosavePlugin API
autosave.saveNow();    // Force immediate save
autosave.isSaving();   // Check if currently saving

// analyticsPlugin API
analytics.flush();        // Force flush buffered events
analytics.eventCount();   // Number of buffered events
```
